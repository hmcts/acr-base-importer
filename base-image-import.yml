#
# Import new image on base image update
#
name: ACR base image import
trigger: none
pr: none
variables:
  environment: 'nonprod'
  acrName: hmctspublic
  targetRegistry: hmctspublic.azurecr.io

jobs:
- job:
  pool:
    vmImage: 'Ubuntu 16.04'
  strategy:
    maxParallel: 3
    matrix: 
      node-8-alpine:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 8-alpine
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/base/node/alpine-lts-8
      node-10-alpine:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 10-alpine
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/base/node/alpine-lts-10
      openjdk-8-distroless:
        baseImage: distroless/java
        baseRegistry: gcr.io
        baseTag: 8
        baseImageType: gcr  # docker or gcr
        targetImage: hmcts/base/java/distroless-8
  steps:
  - task: AzureCLI@1
    displayName: 'Check base registry if new digest available for tag'
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Get digest for tag from base registry (e.g. docker)
        if [ $(baseImageType) == "docker" ]
        then
          # docker registry
          _token=$(curl --silent "https://auth.docker.io/token?scope=repository:$(baseImage):pull&service=registry.docker.io" | jq -r '.token')
          _digest=$(curl -i --silent --header "Accept: application/vnd.docker.distribution.manifest.v2+json" --header "Authorization: Bearer $_token" \
            "https://registry-1.docker.io/v2/$(baseImage)/manifests/$(baseTag)" |grep -i '[Dd]ocker-[Cc]ontent-[Dd]igest:' \
            |sed 's/[Dd]ocker-[Cc]ontent-[Dd]igest: *\(sha256:[a-zA-Z0-9]*\)/\1/' |tr -d '\r\n')
        else
          # google registry (gcr)
          _digest=$(curl -i --silent "https://gcr.io/v2/$(baseImage)/manifests/$(baseTag)" |grep -i '[Dd]ocker-[Cc]ontent-[Dd]igest:' \
            |sed 's/[Dd]ocker-[Cc]ontent-[Dd]igest: *\(sha256:[a-zA-Z0-9]*\)/\1/' |tr -d '\r\n')
        fi
        [ "$_digest" == "" ] && echo "Error: cannot get image digest for $(baseImage):$(baseTag)" && exit 1
        # Get current digest from target azure registry
        echo "Base registry current digest for $(baseImage):$(baseTag): [${_digest}]"
        _acr_digest=$(az acr repository show-manifests -n $(acrName) --repository $(targetImage) \
          --query '[?not_null(tags[])]|[?contains(tags, `$(baseTag)`)].digest|[0]' |tr -d '"[:blank:]' |xargs echo -n)
        echo "Target registry current digest for $(baseImage):$(baseTag): [${_acr_digest}]"
        [[ "$_acr_digest" != "" && "$_acr_digest" == "$_digest" ]] && echo "Nothing to import for $(baseRegistry)/$(baseImage)." && exit 0  # Nothing else to do
        #[[ $? -ne 0 ]] && exit 11
        # Export variables for next stages
        echo "##vso[task.setvariable variable=newTagFound]true" 
        echo "##vso[task.setvariable variable=acrDigest]$_acr_digest"
        echo "##vso[task.setvariable variable=baseDigest]${_digest:7:6}"

  - task: Docker@2
    displayName: 'Import gcr image (pull)' # acr import does not work with gcr (see: https://github.com/Azure/azure-cli/issues/9557)
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'gcr'))
    inputs:
      command: pull
      repository: $(baseRegistry)/$(baseImage)
      tags: $(baseTag)
      arguments: $(baseRegistry)/$(baseImage):$(baseTag)

  - task: Docker@2
    displayName: 'Import gcr image (tag)'
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'gcr'))
    inputs:
      command: tag
      repository: $(baseRegistry)/$(baseImage)
      tags: $(baseTag)
      arguments: $(baseRegistry)/$(baseImage):$(baseTag) $(targetRegistry)/$(targetImage):$(baseTag)-$(baseDigest)

  - task: Docker@2
    displayName: 'Import gcr image (push)'
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'gcr'))
    inputs:
      command: push
      #repository: $(targetRegistry)/$(targetImage)
      #tags: $(baseTag)-$(baseDigest)
      arguments: $(targetRegistry)/$(targetImage):$(baseTag)-$(baseDigest)

  - task: AzureCLI@1
    displayName: 'Import docker image'
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'docker'))
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        echo "Importing $(baseRegistry)/$(baseImage):$(baseTag) ..."
        az acr import --name $(acrName) --source $(baseRegistry)/$(baseImage):$(baseTag) --image $(targetImage):$(baseTag)-$(baseDigest) 

  - task: AzureCLI@1
    displayName: 'Security scan new image'
    condition: eq(variables['newTagFound'], 'true')
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Scan new image. Only execute next step if this passes. Otherwise notify ...
        echo "This is a placeholder for NeuVector image scan"

  - task: AzureCLI@1
    displayName: 'Re-tag new image using the base tag'
    condition: eq(variables['newTagFound'], 'true')
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Move base tag to new image
        [ "$(acrDigest)" != "" ] && echo "Untagging previous $(baseTag) ..." && az acr repository untag -n $(acrName) --image $(targetImage):$(baseTag)
        echo "Tagging $(baseTag)-$(baseDigest) as $(baseTag) ..."
        az acr import --name $(acrName) --source $(targetRegistry)/$(targetImage):$(baseTag)-$(baseDigest) --image $(targetImage):$(baseTag) 
        echo "Done."
