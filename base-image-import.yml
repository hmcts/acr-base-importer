#
# Import new image on base image update
#
name: ACR base image import
trigger: none
pr: none
variables:
  environment: 'nonprod'
  acrName: hmctspublic
  targetRegistry: hmctspublic.azurecr.io

jobs:
- job:
  pool:
    vmImage: 'Ubuntu 16.04'
  strategy:
    maxParallel: 4
    matrix: 
      node-8-alpine:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 8-alpine
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/library/node-alpine-lts-8
      node-10-alpine:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 10-alpine
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/library/node-alpine-lts-10
      node-8-stretch-slim:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 8-stretch-slim
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/library/node-stretch-slim-lts-8
      node-10-stretch-slim:
        baseImage: library/node
        baseRegistry: docker.io
        baseTag: 10-stretch-slim
        baseImageType: docker  # docker or gcr
        targetImage: hmcts/library/node-stretch-slim-lts-10
      openjdk-8-distroless:
        baseImage: distroless/java
        baseRegistry: gcr.io
        baseTag: 8
        baseImageType: gcr  # docker or gcr
        targetImage: hmcts/library/java-distroless
      openjdk-8-debug-distroless:
        baseImage: distroless/java
        baseRegistry: gcr.io
        baseTag: 8-debug
        baseImageType: gcr  # docker or gcr
        targetImage: hmcts/library/java-distroless
      openjdk-11-distroless:
        baseImage: distroless/java
        baseRegistry: gcr.io
        baseTag: 11
        baseImageType: gcr  # docker or gcr
        targetImage: hmcts/library/java-distroless
      openjdk-11-debug-distroless:
        baseImage: distroless/java
        baseRegistry: gcr.io
        baseTag: 11-debug
        baseImageType: gcr  # docker or gcr
        targetImage: hmcts/library/java-distroless
  steps:
  - task: AzureCLI@1
    displayName: 'Check base registry if new digest available for tag'
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'scriptPath'
      scriptPath: check-base-tag.sh
      arguments: $(baseImage) $(baseRegistry) $(baseTag) $(targetImage) $(baseImageType) $(acrName)

  - task: AzureCLI@1
    displayName: 'Import gcr image' # acr import does not work with gcr (see: https://github.com/Azure/azure-cli/issues/9557)
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'gcr'))
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'scriptPath'
      scriptPath: import-gcr-image.sh
      arguments: $(baseImage) $(baseRegistry) $(baseTag) $(targetImage) $(acrName) $(targetRegistry) $(baseDigest)

  - task: AzureCLI@1
    displayName: 'Import docker image'
    condition: and(eq(variables['newTagFound'], 'true'), eq(variables['baseImageType'], 'docker'))
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        echo "Importing $(baseRegistry)/$(baseImage):$(baseTag) ..."
        az acr import --name $(acrName) --source $(baseRegistry)/$(baseImage):$(baseTag) --image $(targetImage):$(baseTag)-$(baseDigest) 

  - task: AzureCLI@1
    displayName: 'Security scan new image'
    condition: eq(variables['newTagFound'], 'true')
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Scan new image. Only execute next step if this passes. Otherwise notify ...
        echo "This is a placeholder for NeuVector image scan"

  - task: AzureCLI@1
    displayName: 'Re-tag new image using the base tag'
    condition: eq(variables['newTagFound'], 'true')
    inputs:
      azureSubscription: azurerm-nonprod
      scriptLocation: 'scriptPath'
      scriptPath: tag-new-image.sh
      arguments: $(baseTag) $(targetImage) $(acrName) $(targetRegistry) $(acrDigest) $(baseDigest)
