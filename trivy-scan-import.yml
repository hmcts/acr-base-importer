#
## Scan and import container images using Trivy
## This pipeline scans container images for vulnerabilities before importing to ACR
##
name: Trivy Scan and ACR Import

trigger:
  - master
pr: none
schedules:
- cron: '0 1 * * *'
  displayName: Daily vulnerability scan and import
  branches:
    include:
    - master
  always: 'true'

# Define images to scan as a parameter (allows modification at queue time)
parameters:
- name: imagesToScan
  type: object
  displayName: 'Images to scan and import'
  default:
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java25-debian13'
    baseTag: 'latest'
    targetImage: 'imported/distroless/java25'
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java25-debian13'
    baseTag: 'debug'
    targetImage: 'imported/distroless/java25'
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java21-debian12'
    baseTag: 'latest'
    targetImage: 'imported/distroless/java21'
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java21-debian12'
    baseTag: 'debug'
    targetImage: 'imported/distroless/java21'
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java17-debian12'
    baseTag: 'latest'
    targetImage: 'imported/distroless/java17'
  - baseRegistry: 'gcr.io'
    baseImage: 'distroless/java17-debian12'
    baseTag: 'debug'
    targetImage: 'imported/distroless/java17'

variables:
  acrName: hmctspublic
  targetRegistry: hmctspublic.azurecr.io
  keyvaultName: 'infra-vault-prod'
  serviceConnection: 'DCD-CNP-PROD'
  # Trivy configuration
  trivyVersion: '0.68.1'  # Latest stable release with improved vulnerability detection
  severityThreshold: 'CRITICAL,HIGH'
  trivyTimeout: '10m'

jobs:
- job: ScanAndImportImages
  displayName: 'Scan with Trivy and Import to ACR'
  timeoutInMinutes: 120  # 2 hours max - prevents hanging
  pool:
    name: hmcts-cftptl-agent-pool

  steps:
  # Get secrets from Key Vault for ACR authentication and notifications
  - task: AzureKeyVault@2
    displayName: 'Get ACR credentials from Key Vault'
    inputs:
      azureSubscription: $(serviceConnection)
      keyVaultName: $(keyvaultName)
      secretsFilter: 'registry-public-username,registry-public-password,registry-slack-webhook'

  # Install Trivy scanner
  - task: Bash@3
    displayName: 'Install Trivy Scanner'
    inputs:
      targetType: 'inline'
      script: |
        set -e
        echo "Installing Trivy version $(trivyVersion)..."

        # Download Trivy binary and checksums
        wget -q https://github.com/aquasecurity/trivy/releases/download/v$(trivyVersion)/trivy_$(trivyVersion)_Linux-64bit.tar.gz
        wget -q https://github.com/aquasecurity/trivy/releases/download/v$(trivyVersion)/trivy_$(trivyVersion)_checksums.txt

        # Verify checksum
        echo "Verifying checksum..."
        grep "trivy_$(trivyVersion)_Linux-64bit.tar.gz" trivy_$(trivyVersion)_checksums.txt | sha256sum -c -

        # Extract to current working directory
        tar -xzf trivy_$(trivyVersion)_Linux-64bit.tar.gz

        # Clean up
        rm -f trivy_$(trivyVersion)_Linux-64bit.tar.gz trivy_$(trivyVersion)_checksums.txt

        # Verify installation
        ./trivy --version

        echo "Trivy installed successfully"

  # Update Trivy vulnerability database once for all scans
  - task: Bash@3
    displayName: 'Update Trivy vulnerability database'
    inputs:
      targetType: 'inline'
      script: |
        set -e

        # Configure Trivy cache directory
        export TRIVY_CACHE_DIR="${HOME}/.cache/trivy"
        mkdir -p "$TRIVY_CACHE_DIR"

        echo "Updating Trivy vulnerability database..."
        # Retry up to 3 times with exponential backoff if database download fails
        for i in 1 2 3; do
          echo "Database download attempt $i of 3..."
          if ./trivy image --download-db-only; then
            echo "Vulnerability database updated successfully"
            break
          else
            if [ $i -eq 3 ]; then
              echo "##vso[task.logissue type=error]Failed to download vulnerability database after 3 attempts"
              exit 1
            fi
            echo "Download failed, waiting before retry..."
            sleep $((5 * i))  # Wait 5s, 10s, 15s
          fi
        done

        echo "Updating Trivy Java database..."
        # Download Java DB for scanning Java images
        for i in 1 2 3; do
          echo "Java DB download attempt $i of 3..."
          if ./trivy image --download-java-db-only; then
            echo "Java database updated successfully"
            echo "Cache location: $TRIVY_CACHE_DIR"
            break
          else
            if [ $i -eq 3 ]; then
              echo "##vso[task.logissue type=error]Failed to download Java database after 3 attempts"
              exit 1
            fi
            echo "Download failed, waiting before retry..."
            sleep $((5 * i))  # Wait 5s, 10s, 15s
          fi
        done

  # Loop over each image using Azure DevOps native each loops
  - ${{ each image in parameters.imagesToScan }}:
    # Check if new version exists
    - task: AzureCLI@2
      displayName: 'Check version: ${{ image.baseImage }}:${{ image.baseTag }}'
      name: check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: scriptPath
        scriptPath: check-base-tag.sh
        arguments: >
          --baseImage "${{ image.baseImage }}"
          --baseRegistry "${{ image.baseRegistry }}"
          --baseTag "${{ image.baseTag }}"
          --targetImage "${{ image.targetImage }}"
          --acrName "$(acrName)"

    # Scan image with Trivy (only if new version found)
    - task: Bash@3
      displayName: 'Scan: ${{ image.baseImage }}:${{ image.baseTag }}'
      name: scan_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}
      condition: eq(variables['check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.newTagFound'], 'true')
      inputs:
        targetType: 'inline'
        script: |
          set -e

          IMAGE_TO_SCAN="${{ image.baseRegistry }}/${{ image.baseImage }}:${{ image.baseTag }}"
          SAFE_NAME="${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}"

          echo "Scanning: $IMAGE_TO_SCAN"

          # Scan image and save JSON
          ./trivy image \
            --severity $(severityThreshold) \
            --format json \
            --timeout $(trivyTimeout) \
            --ignore-unfixed \
            --scanners vuln \
            --output "trivy-report-${SAFE_NAME}.json" \
            "$IMAGE_TO_SCAN"

          # Parse vulnerabilities
          REPORT_FILE="trivy-report-${SAFE_NAME}.json"
          CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' "$REPORT_FILE")
          HIGH_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' "$REPORT_FILE")

          # Generate human-readable table
          ./trivy convert \
            --format table \
            --output "trivy-scan-${SAFE_NAME}.txt" \
            "$REPORT_FILE" || true

          # Display table in console for readability
          echo ""
          echo "=== Vulnerability Scan Report ==="
          cat "trivy-scan-${SAFE_NAME}.txt" || echo "Unable to display report"
          echo "=================================="
          echo ""

          echo "Vulnerabilities: Critical=$CRITICAL_COUNT, High=$HIGH_COUNT"

          # Determine pass/fail based on critical count
          if [ "$CRITICAL_COUNT" -eq 0 ]; then
            echo "##vso[task.setvariable variable=scanPassed;isOutput=true]true"
            echo "✓ Scan passed - no critical vulnerabilities"
          else
            echo "##vso[task.setvariable variable=scanPassed;isOutput=true]false"
            echo "##vso[task.logissue type=warning]Found $CRITICAL_COUNT critical vulnerabilities"
            echo "✗ Scan failed - blocking import"
            exit 1
          fi

    # Import to ACR (only if scan passed)
    - task: AzureCLI@2
      displayName: 'Import: ${{ image.baseImage }}:${{ image.baseTag }}'
      condition: |
        and(
          eq(variables['check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.newTagFound'], 'true'),
          eq(variables['scan_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.scanPassed'], 'true')
        )
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e

          BASE_DIGEST="$(check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.baseDigest)"

          echo "Importing ${{ image.baseRegistry }}/${{ image.baseImage }}:${{ image.baseTag }}"
          echo "Base digest: $BASE_DIGEST"

    # Re-tag image
    - task: AzureCLI@2
      displayName: 'Tag: ${{ image.baseImage }}:${{ image.baseTag }}'
      condition: |
        and(
          eq(variables['check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.newTagFound'], 'true'),
          eq(variables['scan_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.scanPassed'], 'true')
        )
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: scriptPath
        scriptPath: tag-new-image.sh
        arguments: >
          --baseTag "${{ image.baseTag }}"
          --targetImage "${{ image.targetImage }}"
          --acrName "$(acrName)"
          --targetRegistry "$(targetRegistry)"
          --baseDigest "$(check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.baseDigest)"
          --acrDigest "$(check_${{ replace(replace(image.baseImage, '/', '_'), '-', '_') }}_${{ replace(image.baseTag, '-', '_') }}.acrDigest)"

  - job: CreateACRCache
    dependsOn: ScanAndImportImages
    condition: succeeded()
    pool:
      vmImage: ubuntu-latest
    steps:
      - task: AzureCLI@2
        displayName: 'Create ACR Cache'
        inputs:
          azureSubscription: $(serviceConnection)
          scriptType: bash
          scriptLocation: scriptPath
          scriptPath: acr-cache.sh
